{
  "higher-order-observables": [
    {
      "question": "Explain the difference between mergeMap, switchMap, concatMap, and exhaustMap.",
      "answer": "mergeMap processes all inner observables concurrently. switchMap cancels previous inner observables and switches to the latest. concatMap processes inner observables sequentially in order. exhaustMap ignores new values while current inner observable is active.",
      "example": "// mergeMap - concurrent\nsource$.pipe(mergeMap(val => http.get(url)))\n\n// switchMap - cancel previous\nsearch$.pipe(switchMap(term => http.get(searchUrl)))\n\n// concatMap - sequential\nqueue$.pipe(concatMap(item => processItem(item)))\n\n// exhaustMap - ignore while busy\nlogin$.pipe(exhaustMap(() => authService.login()))"
    },
    {
      "question": "When would you choose switchMap over mergeMap?",
      "answer": "Use switchMap when you only care about the latest result and want to cancel previous operations, such as search autocomplete, navigation, or any scenario where newer requests make older ones irrelevant.",
      "example": "// Search autocomplete\nsearchInput$.pipe(\n  debounceTime(300),\n  switchMap(term => searchService.search(term))\n).subscribe(results => displayResults(results));"
    },
    {
      "question": "How do you handle errors in higher-order observables?",
      "answer": "Handle errors at both the outer and inner observable levels. Use catchError on inner observables to prevent the outer stream from terminating, and consider using retry operators for transient failures.",
      "example": "source$.pipe(\n  mergeMap(val => \n    http.get(url).pipe(\n      catchError(err => of(defaultValue))\n    )\n  ),\n  catchError(err => of([]))\n)"
    },
    {
      "question": "What are the performance implications of different flattening operators?",
      "answer": "mergeMap can create many concurrent subscriptions leading to memory issues. switchMap is memory efficient as it cancels previous subscriptions. concatMap can cause backpressure if inner observables are slow. exhaustMap is most memory efficient for preventing duplicate operations."
    },
    {
      "question": "How would you implement a retry mechanism with higher-order observables?",
      "answer": "Use retryWhen with switchMap or mergeMap to implement custom retry logic with delays, exponential backoff, or conditional retries based on error types.",
      "example": "source$.pipe(\n  retryWhen(errors =>\n    errors.pipe(\n      switchMap((error, index) =>\n        index < 3 ? timer(1000 * Math.pow(2, index)) : throwError(error)\n      )\n    )\n  )\n)"
    }
  ],
  "custom-operators": [
    {
      "question": "How do you create a reusable custom operator in RxJS?",
      "answer": "Create a function that returns another function which takes an Observable as input and returns an Observable as output. This follows the operator pattern used by built-in RxJS operators.",
      "example": "export function debug<T>(tag: string) {\n  return (source: Observable<T>) => {\n    return source.pipe(\n      tap(value => console.log(`[${tag}]:`, value))\n    );\n  };\n}"
    },
    {
      "question": "What are the benefits of creating custom operators?",
      "answer": "Custom operators promote code reusability, encapsulate complex logic, improve readability, make testing easier, and allow for domain-specific transformations that can be shared across the application."
    },
    {
      "question": "How do you test custom operators?",
      "answer": "Test custom operators by creating test observables, applying the operator, and asserting the expected output. Use marble testing for complex scenarios with timing.",
      "example": "it('should filter truthy values', () => {\n  const source$ = of(1, 0, 'hello', null, true);\n  const result$ = source$.pipe(filterTruthy());\n  \n  result$.subscribe(values => {\n    expect(values).toEqual([1, 'hello', true]);\n  });\n});"
    },
    {
      "question": "What is the difference between pipeable and creation operators?",
      "answer": "Pipeable operators transform existing observables and are used with the pipe() method. Creation operators create new observables from scratch. Custom operators are typically pipeable operators."
    },
    {
      "question": "How do you handle parameters in custom operators?",
      "answer": "Use a higher-order function pattern where the outer function accepts parameters and returns the actual operator function.",
      "example": "export function retryWithDelay(retries: number, delayMs: number) {\n  return <T>(source: Observable<T>) => {\n    return source.pipe(\n      retryWhen(errors => \n        errors.pipe(\n          delay(delayMs),\n          take(retries)\n        )\n      )\n    );\n  };\n}"
    }
  ],
  "error-handling": [
    {
      "question": "What are the different strategies for error handling in RxJS?",
      "answer": "Main strategies include: catchError for graceful recovery, retry for automatic retries, retryWhen for custom retry logic, throwError for re-throwing errors, and finalize for cleanup operations regardless of success or failure.",
      "example": "source$.pipe(\n  retry(3),\n  catchError(error => {\n    console.error('Operation failed:', error);\n    return of(fallbackValue);\n  }),\n  finalize(() => console.log('Cleanup'))\n)"
    },
    {
      "question": "How do you implement exponential backoff retry strategy?",
      "answer": "Use retryWhen with increasing delays between retry attempts, typically doubling the delay each time until a maximum is reached.",
      "example": "source$.pipe(\n  retryWhen(errors =>\n    errors.pipe(\n      scan((retryCount, error) => {\n        if (retryCount >= 3) throw error;\n        return retryCount + 1;\n      }, 0),\n      delayWhen(retryCount => timer(Math.pow(2, retryCount) * 1000))\n    )\n  )\n)"
    },
    {
      "question": "What is the difference between local and global error handling?",
      "answer": "Local error handling occurs within specific observable streams using operators like catchError. Global error handling catches unhandled errors at the application level, typically using Angular's ErrorHandler or RxJS's global error handler."
    },
    {
      "question": "How do you prevent error propagation in nested observables?",
      "answer": "Use catchError within inner observables to handle errors locally and prevent them from terminating the outer observable stream.",
      "example": "source$.pipe(\n  mergeMap(value =>\n    innerObservable$.pipe(\n      catchError(error => {\n        console.error('Inner error:', error);\n        return of(defaultValue);\n      })\n    )\n  )\n)"
    },
    {
      "question": "When should you use throwError vs catchError?",
      "answer": "Use catchError to handle and recover from errors by providing fallback values or alternative streams. Use throwError to create error observables for testing or to re-throw errors after logging or processing them."
    }
  ],
  "hot-cold-observables": [
    {
      "question": "Explain the fundamental difference between Hot and Cold Observables.",
      "answer": "<strong>Cold Observables:</strong> Unicast, lazy execution, each subscriber gets independent execution. Data producer is created inside the Observable.<br><br><strong>Hot Observables:</strong> Multicast, eager execution, all subscribers share the same execution. Data producer exists outside the Observable.",
      "example": "// Cold Observable\nconst cold$ = new Observable(subscriber => {\n  const data = Math.random(); // New value for each subscriber\n  subscriber.next(data);\n});\n\n// Hot Observable\nconst subject = new Subject();\nconst hot$ = subject.asObservable();\nsubject.next(Math.random()); // Same value for all subscribers"
    },
    {
      "question": "How do you convert a Cold Observable to Hot?",
      "answer": "Use operators like <code>share()</code>, <code>shareReplay()</code>, <code>publish()</code> + <code>connect()</code>, or <code>multicast()</code> with a Subject. These operators enable multicasting so multiple subscribers share the same execution.",
      "example": "// Using share()\nconst hot$ = cold$.pipe(share());\n\n// Using publish() + connect()\nconst published$ = cold$.pipe(publish());\npublished$.connect();\n\n// Using shareReplay()\nconst replayed$ = cold$.pipe(shareReplay(1));"
    },
    {
      "question": "What are the practical implications of Hot vs Cold Observables?",
      "answer": "<strong>Cold:</strong> Each HTTP request creates a new call, timers restart for each subscriber, good for independent operations.<br><br><strong>Hot:</strong> Shared resources like WebSocket connections, DOM events, prevents duplicate API calls, but late subscribers miss previous emissions."
    },
    {
      "question": "When would you choose Hot Observables over Cold?",
      "answer": "Choose Hot when you want to share expensive operations (HTTP calls, WebSocket connections), prevent duplicate work, or when dealing with live data streams like user events, real-time updates, or when multiple components need the same data.",
      "example": "// Shared HTTP call\nconst sharedData$ = this.http.get('/api/data').pipe(\n  shareReplay(1)\n);\n\n// Multiple components can subscribe without duplicate calls\ncomponent1.subscribe(sharedData$);\ncomponent2.subscribe(sharedData$);"
    },
    {
      "question": "How do Subjects relate to Hot and Cold Observables?",
      "answer": "All Subject types (Subject, BehaviorSubject, ReplaySubject, AsyncSubject) are Hot Observables by nature. They multicast to multiple subscribers and maintain their own state independent of subscriptions.",
      "example": "// BehaviorSubject - Hot with initial value\nconst behavior$ = new BehaviorSubject('initial');\n\n// ReplaySubject - Hot with replay capability\nconst replay$ = new ReplaySubject(3);\n\n// Both share emissions among all subscribers"
    },
    {
      "question": "What is the difference between share() and shareReplay()?",
      "answer": "<code>share()</code> creates a Hot Observable but new subscribers only get future emissions. <code>shareReplay(n)</code> also replays the last 'n' emissions to new subscribers, making it useful for caching scenarios.",
      "example": "// share() - only future values\nconst shared$ = source$.pipe(share());\n\n// shareReplay() - replays last 2 values\nconst replayed$ = source$.pipe(shareReplay(2));\n\n// Late subscribers to replayed$ get last 2 values immediately"
    },
    {
      "question": "How do you handle memory leaks with Hot Observables?",
      "answer": "Hot Observables can cause memory leaks if not properly managed. Always unsubscribe, use takeUntil pattern, or use async pipe in templates. Be careful with shareReplay() as it keeps references to emitted values.",
      "example": "// Safe pattern with takeUntil\nprivate destroy$ = new Subject<void>();\n\nhot$.pipe(\n  takeUntil(this.destroy$)\n).subscribe();\n\nngOnDestroy() {\n  this.destroy$.next();\n  this.destroy$.complete();\n}"
    },
    {
      "question": "What happens when you subscribe to a Cold Observable multiple times?",
      "answer": "Each subscription creates a new independent execution of the Observable. This means separate HTTP requests, separate timer instances, and potentially different emitted values for each subscriber.",
      "example": "const cold$ = this.http.get('/api/data');\n\n// Creates 2 separate HTTP requests\ncold$.subscribe(data1 => console.log('Sub 1:', data1));\ncold$.subscribe(data2 => console.log('Sub 2:', data2));"
    }
  ],
  "schedulers": [
    {
      "question": "What are RxJS Schedulers and why are they important?",
      "answer": "<strong>Schedulers</strong> control when and how observables emit values and when subscriptions are executed. They provide control over the execution context, timing, and concurrency of observable operations. This is crucial for performance optimization, testing, and managing different execution environments.",
      "example": "// Without scheduler - default behavior\nof(1, 2, 3).subscribe(console.log);\n\n// With asyncScheduler - asynchronous execution\nof(1, 2, 3).pipe(\n  observeOn(asyncScheduler)\n).subscribe(console.log);"
    },
    {
      "question": "Explain the difference between subscribeOn and observeOn.",
      "answer": "<code>subscribeOn</code> controls the scheduler used when the Observable is subscribed to (affects the entire chain). <code>observeOn</code> controls the scheduler used for emitting values from that point forward in the chain.",
      "example": "source$.pipe(\n  subscribeOn(asyncScheduler), // Subscription happens async\n  map(x => x * 2),\n  observeOn(queueScheduler),   // Emissions from here are sync\n  filter(x => x > 5)\n).subscribe(console.log);"
    },
    {
      "question": "When would you use each type of scheduler?",
      "answer": "<strong>asyncScheduler:</strong> For delays and asynchronous operations<br><strong>queueScheduler:</strong> For synchronous, immediate execution<br><strong>asapScheduler:</strong> For microtask execution (high priority)<br><strong>animationFrameScheduler:</strong> For smooth browser animations<br><strong>TestScheduler:</strong> For testing with virtual time"
    },
    {
      "question": "How do you use schedulers for performance optimization?",
      "answer": "Use appropriate schedulers to control when expensive operations run. <code>asyncScheduler</code> can prevent blocking the main thread, <code>animationFrameScheduler</code> ensures smooth animations, and <code>queueScheduler</code> can batch synchronous operations.",
      "example": "// Expensive computation on async scheduler\nfrom(largeArray).pipe(\n  observeOn(asyncScheduler),\n  map(expensiveOperation),\n  observeOn(animationFrameScheduler) // Smooth UI updates\n).subscribe(updateUI);"
    },
    {
      "question": "How do you test observables with schedulers?",
      "answer": "Use <code>TestScheduler</code> to control virtual time and test timing-dependent operations. It allows you to advance time manually and test complex async scenarios synchronously.",
      "example": "const testScheduler = new TestScheduler((actual, expected) => {\n  expect(actual).toEqual(expected);\n});\n\ntestScheduler.run(({ cold, expectObservable }) => {\n  const source$ = cold('a-b-c|');\n  const expected = 'a-b-c|';\n  expectObservable(source$).toBe(expected);\n});"
    },
    {
      "question": "What are the performance implications of different schedulers?",
      "answer": "<strong>queueScheduler:</strong> Fastest but can block the main thread<br><strong>asyncScheduler:</strong> Non-blocking but has setTimeout overhead<br><strong>asapScheduler:</strong> Fast microtask execution<br><strong>animationFrameScheduler:</strong> Synced with browser repaint, good for animations but limited to ~60fps"
    },
    {
      "question": "How do schedulers work with operators like delay and debounceTime?",
      "answer": "Many RxJS operators accept an optional scheduler parameter to control their timing behavior. This allows you to customize when delays occur and how timing-based operations execute.",
      "example": "// Custom scheduler for delay\nsource$.pipe(\n  delay(1000, asyncScheduler),\n  debounceTime(300, asapScheduler)\n).subscribe(console.log);\n\n// Testing with TestScheduler\nsource$.pipe(\n  delay(1000, testScheduler)\n) // Controllable in tests"
    },
    {
      "question": "What happens if you don't specify a scheduler?",
      "answer": "RxJS uses sensible defaults based on the operator and context. Most operators use synchronous execution by default, while time-based operators like <code>delay</code>, <code>timer</code>, and <code>interval</code> use <code>asyncScheduler</code> by default.",
      "example": "// Default behaviors\nof(1, 2, 3) // queueScheduler (sync)\ntimer(1000)  // asyncScheduler\ninterval(100) // asyncScheduler\nanimationFrames() // animationFrameScheduler"
    }
  ],
  "subjects-multicasting": [
    {
      "question": "Explain the difference between Subjects and regular Observables.",
      "answer": "<strong>Regular Observables:</strong> Unicast, each subscriber gets independent execution, data producer inside Observable.<br><br><strong>Subjects:</strong> Multicast, all subscribers share same execution, act as both Observable and Observer, can emit values imperatively using next().",
      "example": "// Regular Observable - unicast\nconst obs$ = new Observable(sub => sub.next(Math.random()));\n\n// Subject - multicast\nconst subject = new Subject();\nsubject.next(Math.random()); // Same value for all subscribers"
    },
    {
      "question": "When would you use each type of Subject?",
      "answer": "<strong>Subject:</strong> Event buses, notifications, simple multicasting<br><strong>BehaviorSubject:</strong> State management, current user, settings<br><strong>ReplaySubject:</strong> Caching, chat history, recent activities<br><strong>AsyncSubject:</strong> Final results, completion status, last computed value",
      "example": "// State management with BehaviorSubject\nconst currentUser$ = new BehaviorSubject(null);\n\n// Chat history with ReplaySubject\nconst chatHistory$ = new ReplaySubject(50);\n\n// Final result with AsyncSubject\nconst computationResult$ = new AsyncSubject();"
    },
    {
      "question": "How do you implement a simple event bus using Subjects?",
      "answer": "Create a Subject instance and expose it as an Observable. Components can subscribe to receive events and emit events using the Subject's next() method.",
      "example": "class EventBus {\n  private eventSubject = new Subject<any>();\n  \n  emit(event: any) {\n    this.eventSubject.next(event);\n  }\n  \n  on(eventType: string) {\n    return this.eventSubject.pipe(\n      filter(event => event.type === eventType)\n    );\n  }\n}"
    },
    {
      "question": "What are the memory implications of different Subject types?",
      "answer": "<strong>Subject:</strong> No memory overhead, doesn't store values<br><strong>BehaviorSubject:</strong> Stores one current value<br><strong>ReplaySubject:</strong> Can store many values, potential memory leaks if not managed<br><strong>AsyncSubject:</strong> Stores only the last value until completion",
      "example": "// ReplaySubject with buffer limit and time window\nconst replay$ = new ReplaySubject(100, 5000); // Max 100 items, 5 sec window\n\n// Prevent memory leaks\nngOnDestroy() {\n  this.replay$.complete();\n}"
    },
    {
      "question": "How do you handle errors in Subjects?",
      "answer": "When a Subject encounters an error, it terminates and stops emitting values. All subscribers receive the error. To continue after errors, use operators like catchError or create a new Subject.",
      "example": "const subject = new Subject();\n\n// Handle errors without terminating\nsubject.pipe(\n  catchError(error => {\n    console.error('Error:', error);\n    return EMPTY; // Continue without terminating\n  })\n).subscribe();\n\n// Or use a separate error subject\nconst errorSubject = new Subject();"
    },
    {
      "question": "What is the difference between BehaviorSubject and ReplaySubject(1)?",
      "answer": "<strong>BehaviorSubject:</strong> Requires initial value, always has current value, getValue() method available<br><strong>ReplaySubject(1):</strong> No initial value required, may not have any value initially, no getValue() method",
      "example": "// BehaviorSubject - must have initial value\nconst behavior = new BehaviorSubject('initial');\nconsole.log(behavior.getValue()); // 'initial'\n\n// ReplaySubject - no initial value\nconst replay = new ReplaySubject(1);\n// No getValue() method available"
    },
    {
      "question": "How do you implement state management with BehaviorSubject?",
      "answer": "Use BehaviorSubject to store current state, provide methods to update state, and expose state as Observable for components to subscribe to changes.",
      "example": "class StateService {\n  private state$ = new BehaviorSubject(initialState);\n  \n  getState() {\n    return this.state$.asObservable();\n  }\n  \n  updateState(newState: any) {\n    this.state$.next({ ...this.state$.value, ...newState });\n  }\n  \n  getCurrentState() {\n    return this.state$.value;\n  }\n}"
    },
    {
      "question": "What happens when you complete a Subject?",
      "answer": "When completed, a Subject stops emitting values and notifies all subscribers of completion. New subscriptions after completion immediately receive the complete notification. The Subject cannot emit new values after completion.",
      "example": "const subject = new Subject();\n\nsubject.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Completed')\n});\n\nsubject.next('Hello'); // Emitted\nsubject.complete(); // Completes\nsubject.next('World'); // Ignored - no effect"
    }
  ],
  "backpressure-flow-control": [
    {
      "question": "What is backpressure and how do you handle it in RxJS?",
      "answer": "<strong>Backpressure</strong> occurs when data is produced faster than it can be consumed. Handle it using flow control operators like <code>throttleTime</code>, <code>debounceTime</code>, <code>sample</code>, and <code>buffer</code> to control emission rates and prevent memory issues.",
      "example": "// Handle fast scroll events\nfromEvent(window, 'scroll').pipe(\n  throttleTime(100), // Limit to once per 100ms\n  map(() => window.scrollY)\n).subscribe(handleScroll);"
    },
    {
      "question": "When would you use throttleTime vs debounceTime?",
      "answer": "<strong>throttleTime:</strong> Use for events that should be processed at regular intervals (scroll, resize)<br><strong>debounceTime:</strong> Use when you want to wait for a pause in activity (search input, button clicks)",
      "example": "// Throttle - regular intervals\nscroll$.pipe(throttleTime(100))\n\n// Debounce - wait for pause\nsearchInput$.pipe(debounceTime(300))"
    },
    {
      "question": "How do you implement search optimization with RxJS?",
      "answer": "Use <code>debounceTime</code> to wait for typing pauses, <code>distinctUntilChanged</code> to avoid duplicate searches, and <code>switchMap</code> to cancel previous requests.",
      "example": "searchInput$.pipe(\n  debounceTime(300),\n  distinctUntilChanged(),\n  switchMap(term => searchService.search(term))\n).subscribe(results => displayResults(results));"
    },
    {
      "question": "What are buffer operators and when would you use them?",
      "answer": "Buffer operators collect emissions into arrays. Use <code>bufferTime</code> for time-based batching, <code>bufferCount</code> for size-based batching, and <code>buffer</code> for custom triggers.",
      "example": "// Batch clicks for analytics\nclicks$.pipe(\n  bufferTime(5000), // Collect for 5 seconds\n  filter(batch => batch.length > 0)\n).subscribe(batch => analytics.track(batch));"
    },
    {
      "question": "How do you prevent duplicate button clicks?",
      "answer": "Use <code>throttleTime</code> or <code>debounceTime</code> to limit click frequency, or use <code>exhaustMap</code> to ignore clicks while processing.",
      "example": "// Prevent duplicate submissions\nsubmitButton$.pipe(\n  exhaustMap(() => submitForm()),\n  catchError(error => handleError(error))\n).subscribe(result => showSuccess(result));"
    }
  ],
  "testing-marble-diagrams": [
    {
      "question": "How do you write marble tests in RxJS?",
      "answer": "Use <code>TestScheduler</code> with marble syntax to create predictable, synchronous tests for asynchronous Observable behavior. Marble diagrams use characters to represent emissions over virtual time.",
      "example": "const testScheduler = new TestScheduler((actual, expected) => {\n  expect(actual).toEqual(expected);\n});\n\ntestScheduler.run(({ cold, expectObservable }) => {\n  const source$ = cold('a-b-c|');\n  const expected = 'a-b-c|';\n  expectObservable(source$).toBe(expected);\n});"
    },
    {
      "question": "Explain the marble syntax characters and their meanings.",
      "answer": "<strong>Letters/Numbers:</strong> Emitted values<br><strong>-:</strong> Time frame (10ms)<br><strong>|:</strong> Completion<br><strong>#:</strong> Error<br><strong>^:</strong> Subscription point<br><strong>!:</strong> Unsubscription point",
      "example": "// Marble patterns\n'a-b-c|'    // Emit a, b, c then complete\n'a---b---c' // Emit with delays\n'a-b-#'     // Emit a, b then error\n'^--!'      // Subscribe at start, unsubscribe after 3 frames"
    },
    {
      "question": "How do you test operators with marble diagrams?",
      "answer": "Create source observables with <code>cold()</code>, apply operators, and verify results with <code>expectObservable()</code>. Use marble syntax to define expected timing and values.",
      "example": "testScheduler.run(({ cold, expectObservable }) => {\n  const source$ = cold('a-b-c|');\n  const result$ = source$.pipe(map(x => x.toUpperCase()));\n  const expected = 'A-B-C|';\n  \n  expectObservable(result$).toBe(expected);\n});"
    },
    {
      "question": "How do you test error scenarios with marble testing?",
      "answer": "Use the '#' character in marble strings to represent errors, and provide error objects in the marble values map.",
      "example": "testScheduler.run(({ cold, expectObservable }) => {\n  const source$ = cold('a-b-#', { a: 1, b: 2 }, new Error('test'));\n  const result$ = source$.pipe(catchError(() => of('error')));\n  const expected = 'a-b-(e|)';\n  \n  expectObservable(result$).toBe(expected, { a: 1, b: 2, e: 'error' });\n});"
    },
    {
      "question": "What are the advantages of marble testing?",
      "answer": "<strong>Synchronous testing</strong> of async code, <strong>visual documentation</strong> of Observable behavior, <strong>precise timing control</strong>, and ability to test complex scenarios with multiple streams and timing dependencies."
    }
  ],
  "combining-transforming-observables": [
    {
      "question": "Explain the difference between merge, concat, zip, and combineLatest.",
      "answer": "<strong>merge:</strong> Concurrent emission from multiple sources<br><strong>concat:</strong> Sequential emission, one after another<br><strong>zip:</strong> Pairs values from sources in order<br><strong>combineLatest:</strong> Emits latest values from all sources when any source emits",
      "example": "// merge - concurrent\nmerge(stream1$, stream2$)\n\n// concat - sequential\nconcat(stream1$, stream2$)\n\n// zip - pairs\nzip(stream1$, stream2$)\n\n// combineLatest - latest values\ncombineLatest([stream1$, stream2$])"
    },
    {
      "question": "When would you use combineLatest vs zip?",
      "answer": "<strong>combineLatest:</strong> When you need the current state from multiple sources (form validation, real-time dashboards)<br><strong>zip:</strong> When you need to pair corresponding values in sequence (parallel processing, coordinated operations)",
      "example": "// Form validation with combineLatest\ncombineLatest([name$, email$, password$]).pipe(\n  map(([name, email, password]) => ({\n    valid: name && email && password,\n    values: { name, email, password }\n  }))\n);"
    },
    {
      "question": "What is the difference between scan and reduce?",
      "answer": "<strong>scan:</strong> Emits intermediate accumulated results as they're computed<br><strong>reduce:</strong> Only emits the final accumulated result when the source completes",
      "example": "// scan - running total\nof(1, 2, 3, 4).pipe(scan((acc, val) => acc + val, 0))\n// Emits: 1, 3, 6, 10\n\n// reduce - final total\nof(1, 2, 3, 4).pipe(reduce((acc, val) => acc + val, 0))\n// Emits: 10 (only when complete)"
    },
    {
      "question": "How do you handle different emission rates in combined streams?",
      "answer": "Use appropriate combining operators based on requirements: <code>combineLatest</code> for latest values, <code>withLatestFrom</code> for triggered combinations, or <code>sample</code>/<code>audit</code> for rate limiting.",
      "example": "// Handle fast mouse moves with slow API calls\nmouseMoves$.pipe(\n  withLatestFrom(apiData$),\n  map(([mouseEvent, data]) => processMouseWithData(mouseEvent, data))\n).subscribe();"
    },
    {
      "question": "How do you implement a shopping cart total with RxJS?",
      "answer": "Use <code>scan</code> to accumulate cart changes over time, and <code>map</code> to calculate totals. Combine with item prices using <code>combineLatest</code> for real-time updates.",
      "example": "const cartItems$ = cartActions$.pipe(\n  scan((cart, action) => {\n    switch(action.type) {\n      case 'ADD': return [...cart, action.item];\n      case 'REMOVE': return cart.filter(item => item.id !== action.id);\n      default: return cart;\n    }\n  }, [])\n);\n\nconst total$ = combineLatest([cartItems$, prices$]).pipe(\n  map(([items, prices]) => \n    items.reduce((sum, item) => sum + prices[item.id], 0)\n  )\n);"
    }
  ]
}