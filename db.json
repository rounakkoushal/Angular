[
  {
    "higher-order-observables": [
      {
        "question": "What is the primary characteristic of a higher-order observable?",
        "options": [
          "It emits primitive values",
          "It emits other observables",
          "It has higher priority",
          "It runs on main thread"
        ],
        "correct": 1,
        "explanation": "Higher-order observables emit other observables as their values, creating nested observable streams."
      },
      {
        "question": "Which operator cancels previous inner observables when a new one arrives?",
        "options": [
          "mergeMap",
          "switchMap",
          "concatMap",
          "exhaustMap"
        ],
        "correct": 1,
        "explanation": "switchMap cancels the previous inner observable subscription when a new value arrives."
      },
      {
        "question": "What does concatMap guarantee that mergeMap doesn't?",
        "options": [
          "Better performance",
          "Order preservation",
          "Error handling",
          "Memory efficiency"
        ],
        "correct": 1,
        "explanation": "concatMap maintains the order of emissions by processing inner observables sequentially."
      },
      {
        "question": "When is exhaustMap most useful?",
        "options": [
          "Search functionality",
          "Data transformation",
          "Preventing duplicate operations",
          "Error recovery"
        ],
        "correct": 2,
        "explanation": "exhaustMap ignores new emissions while current inner observable is active, preventing duplicates."
      },
      {
        "question": "What happens with mergeMap when multiple inner observables emit simultaneously?",
        "options": [
          "Only first emission is kept",
          "Emissions are queued",
          "All emissions are merged",
          "Last emission overwrites others"
        ],
        "correct": 2,
        "explanation": "mergeMap allows all inner observables to emit concurrently and merges all their emissions."
      },
      {
        "question": "Which scenario is ideal for switchMap?",
        "options": [
          "File upload queue",
          "Real-time search",
          "Sequential API calls",
          "Login attempts"
        ],
        "correct": 1,
        "explanation": "switchMap is perfect for search as it cancels outdated requests when new search terms arrive."
      },
      {
        "question": "What is the main memory concern with mergeMap?",
        "options": [
          "CPU usage",
          "Multiple active subscriptions",
          "Slow emissions",
          "Error propagation"
        ],
        "correct": 1,
        "explanation": "mergeMap can create many concurrent subscriptions, potentially leading to memory leaks."
      },
      {
        "question": "How does exhaustMap handle rapid successive emissions?",
        "options": [
          "Processes all",
          "Cancels previous",
          "Ignores new ones",
          "Queues them"
        ],
        "correct": 2,
        "explanation": "exhaustMap ignores new emissions while the current inner observable is still active."
      },
      {
        "question": "What's the relationship between flatMap and mergeMap?",
        "options": [
          "flatMap is deprecated",
          "They are identical",
          "flatMap is faster",
          "mergeMap handles errors better"
        ],
        "correct": 1,
        "explanation": "flatMap and mergeMap are aliases - they perform exactly the same operation."
      },
      {
        "question": "Which operator should you use for a button that triggers HTTP requests?",
        "options": [
          "mergeMap",
          "switchMap",
          "concatMap",
          "exhaustMap"
        ],
        "correct": 3,
        "explanation": "exhaustMap prevents multiple simultaneous requests from rapid button clicks."
      },
      {
        "question": "What does the 'flattening' process do in RxJS?",
        "options": [
          "Reduces array dimensions",
          "Converts higher-order observables to regular observables",
          "Improves performance",
          "Handles errors"
        ],
        "correct": 1,
        "explanation": "Flattening converts nested observable structures into a single observable stream."
      },
      {
        "question": "In which order does concatMap process inner observables?",
        "options": [
          "Random order",
          "Parallel processing",
          "Sequential order",
          "Priority based"
        ],
        "correct": 2,
        "explanation": "concatMap processes inner observables one at a time in the order they were created."
      },
      {
        "question": "What is the key difference between mergeMap and switchMap in terms of subscription management?",
        "options": [
          "No difference",
          "mergeMap keeps all subscriptions active",
          "switchMap keeps all subscriptions active",
          "Both cancel previous subscriptions"
        ],
        "correct": 1,
        "explanation": "mergeMap maintains all inner subscriptions while switchMap cancels previous ones."
      },
      {
        "question": "Which operator would you choose for implementing autocomplete functionality?",
        "options": [
          "mergeMap",
          "switchMap",
          "concatMap",
          "exhaustMap"
        ],
        "correct": 1,
        "explanation": "switchMap is ideal for autocomplete as it cancels previous search requests when new input arrives."
      },
      {
        "question": "What happens if an inner observable in concatMap never completes?",
        "options": [
          "Next observables are processed anyway",
          "The entire stream blocks",
          "An error is thrown",
          "It switches to mergeMap behavior"
        ],
        "correct": 1,
        "explanation": "concatMap waits for each inner observable to complete before processing the next one."
      }
    ]
  },
  {
    "custom-operators": [
      {
        "question": "What is the signature of a custom pipeable operator?",
        "options": [
          "() => Observable",
          "(source: Observable) => Observable",
          "Observable => void",
          "() => void"
        ],
        "correct": 1,
        "explanation": "Custom pipeable operators are functions that take a source Observable and return a new Observable."
      },
      {
        "question": "Which RxJS function is used to create custom operators?",
        "options": [
          "createOperator",
          "pipe",
          "operator",
          "No specific function needed"
        ],
        "correct": 3,
        "explanation": "Custom operators are just functions that return other functions - no special RxJS function is required."
      },
      {
        "question": "What should a custom operator return?",
        "options": [
          "A value",
          "A function",
          "An Observable",
          "A Promise"
        ],
        "correct": 1,
        "explanation": "Custom operators return a function that takes an Observable and returns an Observable."
      },
      {
        "question": "How do you make a custom operator reusable?",
        "options": [
          "Export it as a function",
          "Use global variables",
          "Inline the logic",
          "Use classes"
        ],
        "correct": 0,
        "explanation": "Export custom operators as functions to make them reusable across components."
      },
      {
        "question": "What is the best practice for naming custom operators?",
        "options": [
          "Use camelCase",
          "Use PascalCase",
          "Use snake_case",
          "Use kebab-case"
        ],
        "correct": 0,
        "explanation": "Custom operators should follow camelCase naming convention like built-in RxJS operators."
      }
    ]
  },
  {
    "error-handling": [
      {
        "question": "What does catchError operator return when an error occurs?",
        "options": [
          "void",
          "Error object",
          "Observable",
          "Promise"
        ],
        "correct": 2,
        "explanation": "catchError must return an Observable to continue the stream or handle the error gracefully."
      },
      {
        "question": "Which operator automatically retries failed operations?",
        "options": [
          "catchError",
          "retry",
          "throwError",
          "finalize"
        ],
        "correct": 1,
        "explanation": "The retry operator automatically resubscribes to the source Observable when an error occurs."
      },
      {
        "question": "What happens if you don't handle errors in an Observable stream?",
        "options": [
          "Stream continues",
          "Stream terminates",
          "Error is ignored",
          "Stream restarts"
        ],
        "correct": 1,
        "explanation": "Unhandled errors cause the Observable stream to terminate and stop emitting values."
      },
      {
        "question": "Which operator allows custom retry logic with delays?",
        "options": [
          "retry",
          "retryWhen",
          "catchError",
          "delay"
        ],
        "correct": 1,
        "explanation": "retryWhen allows you to implement custom retry logic with delays and conditions."
      },
      {
        "question": "What is the difference between catchError and retry?",
        "options": [
          "No difference",
          "catchError handles errors, retry repeats operations",
          "retry handles errors, catchError repeats",
          "Both do the same thing"
        ],
        "correct": 1,
        "explanation": "catchError handles and recovers from errors, while retry automatically repeats failed operations."
      }
    ]
  },
  {
    "hot-cold-observables": [
      {
        "question": "What is the main characteristic of a Cold Observable?",
        "options": [
          "Multicast",
          "Unicast",
          "Always hot",
          "Never completes"
        ],
        "correct": 1,
        "explanation": "Cold Observables are unicast - each subscriber gets its own independent execution."
      },
      {
        "question": "When does a Cold Observable start emitting values?",
        "options": [
          "Immediately when created",
          "When subscribed to",
          "After 1 second",
          "When connect() is called"
        ],
        "correct": 1,
        "explanation": "Cold Observables are lazy and only start executing when someone subscribes to them."
      },
      {
        "question": "Which of these is an example of a Hot Observable?",
        "options": [
          "HTTP request",
          "timer()",
          "DOM events",
          "of(1,2,3)"
        ],
        "correct": 2,
        "explanation": "DOM events are Hot Observables as they emit regardless of subscribers and share the same event source."
      },
      {
        "question": "What operator can convert a Cold Observable to Hot?",
        "options": [
          "map",
          "share",
          "filter",
          "take"
        ],
        "correct": 1,
        "explanation": "The share() operator converts Cold Observables to Hot by multicasting to multiple subscribers."
      },
      {
        "question": "In a Hot Observable, what happens to late subscribers?",
        "options": [
          "They get all previous values",
          "They only get future values",
          "They get an error",
          "Observable restarts"
        ],
        "correct": 1,
        "explanation": "Late subscribers to Hot Observables only receive values emitted after their subscription."
      },
      {
        "question": "Which method is used with publish() to start a Hot Observable?",
        "options": [
          "start()",
          "begin()",
          "connect()",
          "activate()"
        ],
        "correct": 2,
        "explanation": "The connect() method is used to start the execution of a published Observable."
      },
      {
        "question": "What happens when multiple subscribers subscribe to the same Cold Observable?",
        "options": [
          "They share the same execution",
          "Each gets independent execution",
          "Only first subscriber works",
          "An error occurs"
        ],
        "correct": 1,
        "explanation": "Each subscriber to a Cold Observable gets its own independent execution of the Observable."
      },
      {
        "question": "Which RxJS Subject type is naturally Hot?",
        "options": [
          "AsyncSubject",
          "BehaviorSubject",
          "ReplaySubject",
          "All Subjects"
        ],
        "correct": 3,
        "explanation": "All Subject types (Subject, BehaviorSubject, ReplaySubject, AsyncSubject) are Hot Observables."
      },
      {
        "question": "What is the main advantage of Hot Observables?",
        "options": [
          "Better performance",
          "Shared execution among subscribers",
          "Easier to debug",
          "Less memory usage"
        ],
        "correct": 1,
        "explanation": "Hot Observables allow multiple subscribers to share the same execution, avoiding duplicate work."
      },
      {
        "question": "Which operator creates a Hot Observable that replays the last N values to new subscribers?",
        "options": [
          "share",
          "shareReplay",
          "publish",
          "multicast"
        ],
        "correct": 1,
        "explanation": "shareReplay() creates a Hot Observable that replays the specified number of last values to new subscribers."
      }
    ]
  },
  {
    "schedulers": [
      {
        "question": "What is the primary purpose of RxJS Schedulers?",
        "options": [
          "Error handling",
          "Control execution timing",
          "Data transformation",
          "Memory management"
        ],
        "correct": 1,
        "explanation": "Schedulers control when and how observables emit values and when subscriptions are executed."
      },
      {
        "question": "Which scheduler executes tasks asynchronously using setTimeout?",
        "options": [
          "queueScheduler",
          "asyncScheduler",
          "asapScheduler",
          "animationFrameScheduler"
        ],
        "correct": 1,
        "explanation": "asyncScheduler uses setTimeout for asynchronous execution with optional delays."
      },
      {
        "question": "What type of execution does queueScheduler provide?",
        "options": [
          "Asynchronous",
          "Synchronous",
          "Parallel",
          "Delayed"
        ],
        "correct": 1,
        "explanation": "queueScheduler executes tasks synchronously in queue order without delays."
      },
      {
        "question": "Which scheduler is best for smooth browser animations?",
        "options": [
          "asyncScheduler",
          "queueScheduler",
          "animationFrameScheduler",
          "asapScheduler"
        ],
        "correct": 2,
        "explanation": "animationFrameScheduler syncs with the browser's repaint cycle for smooth animations."
      },
      {
        "question": "What does asapScheduler use for execution?",
        "options": [
          "setTimeout",
          "setInterval",
          "Promise.resolve()",
          "requestAnimationFrame"
        ],
        "correct": 2,
        "explanation": "asapScheduler uses Promise.resolve() to execute tasks in the microtask queue."
      },
      {
        "question": "Which operator is used to change the scheduler of an Observable?",
        "options": [
          "subscribeOn",
          "observeOn",
          "Both A and B",
          "scheduleOn"
        ],
        "correct": 2,
        "explanation": "Both subscribeOn and observeOn can be used to control scheduling, but for different purposes."
      },
      {
        "question": "When would you use queueScheduler over asyncScheduler?",
        "options": [
          "For animations",
          "For synchronous execution",
          "For delays",
          "For HTTP requests"
        ],
        "correct": 1,
        "explanation": "Use queueScheduler when you need synchronous execution without delays."
      },
      {
        "question": "What is the main difference between subscribeOn and observeOn?",
        "options": [
          "No difference",
          "subscribeOn affects subscription, observeOn affects emissions",
          "observeOn is deprecated",
          "subscribeOn is faster"
        ],
        "correct": 1,
        "explanation": "subscribeOn controls when subscription occurs, observeOn controls when emissions are delivered."
      },
      {
        "question": "Which scheduler would you use for testing with virtual time?",
        "options": [
          "asyncScheduler",
          "TestScheduler",
          "queueScheduler",
          "asapScheduler"
        ],
        "correct": 1,
        "explanation": "TestScheduler is specifically designed for testing with virtual time control."
      },
      {
        "question": "What happens if you don't specify a scheduler?",
        "options": [
          "Error occurs",
          "Uses default scheduler",
          "No execution",
          "Uses asyncScheduler"
        ],
        "correct": 1,
        "explanation": "RxJS uses appropriate default schedulers based on the operator and context."
      }
    ]
  },
  {
    "subjects-multicasting": [
      {
        "question": "What makes Subjects different from regular Observables?",
        "options": [
          "They are faster",
          "They are both Observable and Observer",
          "They handle errors better",
          "They use less memory"
        ],
        "correct": 1,
        "explanation": "Subjects are both Observable (can be subscribed to) and Observer (can emit values), enabling multicasting."
      },
      {
        "question": "Which Subject type stores and emits the current value to new subscribers?",
        "options": [
          "Subject",
          "BehaviorSubject",
          "ReplaySubject",
          "AsyncSubject"
        ],
        "correct": 1,
        "explanation": "BehaviorSubject stores the current value and immediately emits it to new subscribers."
      },
      {
        "question": "What happens when you subscribe to a regular Subject after values have been emitted?",
        "options": [
          "You get all previous values",
          "You get the last value",
          "You only get future values",
          "An error occurs"
        ],
        "correct": 2,
        "explanation": "Regular Subjects don't store values, so late subscribers only receive future emissions."
      },
      {
        "question": "How many previous values does ReplaySubject(3) store?",
        "options": [
          "1",
          "2",
          "3",
          "All values"
        ],
        "correct": 2,
        "explanation": "ReplaySubject(3) stores the last 3 emitted values and replays them to new subscribers."
      },
      {
        "question": "When does AsyncSubject emit values to its subscribers?",
        "options": [
          "Immediately",
          "After each emission",
          "Only when completed",
          "Never"
        ],
        "correct": 2,
        "explanation": "AsyncSubject only emits the last value when the subject completes."
      },
      {
        "question": "What is the main advantage of using Subjects for multicasting?",
        "options": [
          "Better performance",
          "Multiple subscribers share the same execution",
          "Easier error handling",
          "Automatic completion"
        ],
        "correct": 1,
        "explanation": "Subjects enable multiple subscribers to share the same execution, avoiding duplicate work."
      },
      {
        "question": "Which Subject type is best for representing current application state?",
        "options": [
          "Subject",
          "BehaviorSubject",
          "ReplaySubject",
          "AsyncSubject"
        ],
        "correct": 1,
        "explanation": "BehaviorSubject is ideal for state management as it always has a current value."
      },
      {
        "question": "What happens if you call next() on a completed Subject?",
        "options": [
          "Value is emitted normally",
          "Nothing happens",
          "An error is thrown",
          "Subject restarts"
        ],
        "correct": 1,
        "explanation": "Once a Subject is completed, calling next() has no effect - the value is ignored."
      },
      {
        "question": "Which Subject type would you use for implementing a chat history feature?",
        "options": [
          "Subject",
          "BehaviorSubject",
          "ReplaySubject",
          "AsyncSubject"
        ],
        "correct": 2,
        "explanation": "ReplaySubject can store and replay multiple previous messages to new subscribers."
      },
      {
        "question": "Are Subjects Hot or Cold Observables?",
        "options": [
          "Cold",
          "Hot",
          "Both",
          "Neither"
        ],
        "correct": 1,
        "explanation": "All Subject types are Hot Observables - they multicast to multiple subscribers."
      }
    ]
  },
  {
    "backpressure-flow-control": [
      {
        "question": "What is backpressure in RxJS?",
        "options": [
          "Memory leaks",
          "Data produced faster than consumed",
          "Network delays",
          "CPU overload"
        ],
        "correct": 1,
        "explanation": "Backpressure occurs when data is produced faster than it can be consumed, leading to performance issues."
      },
      {
        "question": "Which operator limits the rate of emissions?",
        "options": [
          "debounceTime",
          "throttleTime",
          "delay",
          "bufferTime"
        ],
        "correct": 1,
        "explanation": "throttleTime limits the rate of emissions by allowing only one emission per specified time period."
      },
      {
        "question": "What does debounceTime do?",
        "options": [
          "Delays all emissions",
          "Waits for silence period before emitting",
          "Limits emission rate",
          "Buffers emissions"
        ],
        "correct": 1,
        "explanation": "debounceTime waits for a specified silence period before emitting the latest value."
      },
      {
        "question": "Which operator is best for search input optimization?",
        "options": [
          "throttleTime",
          "debounceTime",
          "sampleTime",
          "bufferTime"
        ],
        "correct": 1,
        "explanation": "debounceTime is ideal for search inputs as it waits for the user to stop typing before triggering a search."
      },
      {
        "question": "What does the buffer operator do?",
        "options": [
          "Delays emissions",
          "Collects emissions into arrays",
          "Limits rate",
          "Samples periodically"
        ],
        "correct": 1,
        "explanation": "The buffer operator collects emissions into arrays based on specified criteria."
      }
    ]
  },
  {
    "testing-marble-diagrams": [
      {
        "question": "What do marble diagrams represent?",
        "options": [
          "Database schemas",
          "Observable streams over time",
          "Component hierarchies",
          "API endpoints"
        ],
        "correct": 1,
        "explanation": "Marble diagrams visually represent Observable streams over time, showing emissions, errors, and completions."
      },
      {
        "question": "In marble syntax, what does the '|' character represent?",
        "options": [
          "Error",
          "Emission",
          "Completion",
          "Time frame"
        ],
        "correct": 2,
        "explanation": "The '|' character represents the completion of an Observable stream in marble syntax."
      },
      {
        "question": "What does the '#' character represent in marble diagrams?",
        "options": [
          "Completion",
          "Error",
          "Emission",
          "Subscription"
        ],
        "correct": 1,
        "explanation": "The '#' character represents an error in marble diagram syntax."
      },
      {
        "question": "Which RxJS tool enables marble testing?",
        "options": [
          "TestScheduler",
          "AsyncScheduler",
          "QueueScheduler",
          "AnimationFrameScheduler"
        ],
        "correct": 0,
        "explanation": "TestScheduler enables marble testing by providing virtual time control for synchronous testing of async operations."
      },
      {
        "question": "What does the '-' character represent in marble syntax?",
        "options": [
          "Error",
          "Completion",
          "Time frame",
          "Subscription"
        ],
        "correct": 2,
        "explanation": "The '-' character represents a time frame (typically 10ms) in marble diagram syntax."
      }
    ]
  },
  {
    "combining-transforming-observables": [
      {
        "question": "What does the merge operator do?",
        "options": [
          "Combines streams sequentially",
          "Combines streams concurrently",
          "Pairs values together",
          "Takes latest values"
        ],
        "correct": 1,
        "explanation": "The merge operator combines multiple Observable streams concurrently, emitting values as they arrive."
      },
      {
        "question": "How does zip differ from combineLatest?",
        "options": [
          "No difference",
          "zip pairs values in order, combineLatest uses latest values",
          "zip is faster",
          "combineLatest is deprecated"
        ],
        "correct": 1,
        "explanation": "zip pairs values from sources in order, while combineLatest emits whenever any source emits using the latest values."
      },
      {
        "question": "What does the scan operator do?",
        "options": [
          "Filters values",
          "Accumulates values over time",
          "Transforms values",
          "Delays emissions"
        ],
        "correct": 1,
        "explanation": "The scan operator accumulates values over time, emitting each intermediate result."
      },
      {
        "question": "When does combineLatest start emitting?",
        "options": [
          "Immediately",
          "After first source emits",
          "After all sources have emitted at least once",
          "After completion"
        ],
        "correct": 2,
        "explanation": "combineLatest waits until all source Observables have emitted at least one value before starting to emit."
      },
      {
        "question": "What is the difference between scan and reduce?",
        "options": [
          "No difference",
          "scan emits intermediate results, reduce emits only final result",
          "reduce is faster",
          "scan handles errors better"
        ],
        "correct": 1,
        "explanation": "scan emits each intermediate accumulated result, while reduce only emits the final accumulated result."
      }
    ]
  }
]